#!/bin/bash

#/*
#简介
#我们知道，Bash 执行脚本时，会创建一个子 Shell。
#$ bash script.sh
#上面代码中，script.sh是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。
#set命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，官方手册有完整清单，本章介绍其中最常用的几个。
#顺便提一下，如果命令行下不带任何参数，直接运行set，会显示所有的环境变量和 Shell 函数。
#*/

#set -u
#如果遇到不存在的变量，Bash 默认忽略它。
##脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。
set -u #脚本报错了，并且不再执行后面的语句。
#echo $a
echo bar


#set -x
#默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。
#set -x用来在运行结果之前，先输出执行的那一行命令。
set -x
echo bar

#脚本当中如果要关闭命令输出，可以使用set +x。

#set -e
#set -e从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。

#set -e根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。
# 这时可以暂时关闭set -e，该命令执行结束后，再重新打开set -e。
set +e
command1
command2
set -e
#set +e表示关闭-e选项，set -e表示重新打开-e选项。


#set -o pipefail
#set -e有一个例外情况，就是不适用于管道命令。
#所谓管道命令，就是多个子命令通过管道运算符（|）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。
#也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e就失效了

#!/usr/bin/env bash
set -e
foo | echo a
echo bar
#结果如下：
#$ bash script.sh
#a
#script.sh:行4: foo: 未找到命令
#bar
#foo是一个不存在的命令，但是foo | echo a这个管道命令会执行成功，导致后面的echo bar会继续执行。
#set -o pipefail用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。


#set -E
#一旦设置了-e参数，会导致函数内的错误不会被trap命令捕获（参考《trap 命令》一章）。-E参数可以纠正这个行为，使得函数也能继承trap命令。


#其他参数
#set命令还有一些其他参数。
#
#set -n：等同于set -o noexec，不运行命令，只检查语法是否正确。
#set -f：等同于set -o noglob，表示不对通配符进行文件名扩展。
#set -v：等同于set -o verbose，表示打印 Shell 接收到的每一行输入。
#set -o noclobber：防止使用重定向运算符>覆盖已经存在的文件。
#上面的-f和-v参数，可以分别使用set +f、set +v关闭。


#set 命令总结
#上面重点介绍的set命令的几个参数，一般都放在一起使用。
# 写法一
set -Eeuxo pipefail

# 写法二
set -Eeux
set -o pipefail
#这两种写法建议放在所有 Bash 脚本的头部。

#另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。
$ bash -euxo pipefail script.sh


#shopt 命令
#shopt命令用来调整 Shell 的参数，跟set命令的作用很类似。之所以会有这两个类似命令的主要原因是，set是从 Ksh 继承的，属于 POSIX 规范的一部分，
# 而shopt是 Bash 特有的。
#直接输入shopt可以查看所有参数，以及它们各自打开和关闭的状态。
#-s用来打开某个参数。
#-u用来关闭某个参数。

#举例来说，histappend这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，
# 那么当前 Shell 的操作历史将替换掉整个历史文件。









