redis相关：
https://www.kancloud.cn/zxliu/redis/2088745

Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。



## 数据类型

Redis支持五种数据类型：

#### string（字符串），

String 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。
常用命令：get、set、incr、decr、mget等。

获取字符串长度
往字符串append内容
设置和获取字符串的某一段内容
设置及获取字符串的某一位（bit）
批量设置一系列字符串的内容
使用场景：常规key-value缓存应用。常规计数: 微博数, 粉丝数。



#### hash（哈希），

Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。
常用命令：hget,hset,hgetall 等。
使用场景：存储部分变更数据，如用户信息等。

Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，使得Hash既没有序列化开销和并发问题，用户ID也不会重复存储，非常适合存储对象

Redis::hset('user:1','name','zhangsan');
Redis::hset('user:1','sex','男');
Redis::hset('user:1','age','20');
dd(Redis::hgetall('user:1'));


简单的购物车功能就可以使用Hash结构快速实现。以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素，如下图所示。
Redis::hset('card:user:1','goods:1','1'); //用户1 增加1个商品1到购物车
Redis::hset('card:user:1','goods:2','2'); //用户2 增加2个商品2到购物车
Redis::hset('card:user:2','goods:1','2'); //用户2 增加2个商品1到购物车

//添加商品购物车
Redis::hset('card:user:1','goods:4','2');
//获取购物车内容
Redis::hgetall('card:user:1');
//增加数量
Redis::hIncrBy('card:user:1','goods:4','2');
//减少数量
Redis::hIncrBy('card:user:1','goods:4','-2');
//删除一个商品
Redis::hdel('card:user:1','goods:4');
//清空购物车
Redis::del('card:user:1');


当一个对象的属性相对整体而且而且不易变化时，比较适合用string存储
比如：
用户：姓名、年龄、地址、爱好、民族、已婚等等
主播：房间号、姓名、年龄、直播领域

当对象的某个属性需要频繁修改，且属性比较零散时，比较适合用hash存储
比如：
用户：喜欢的视频数、



#### list（列表），

常用命令：lpush,rpush,lpop,rpop,lrange等。
场景：
比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。
List的另一个应用就是消息队列， 可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。

实现方式： Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。

消息队列系统
使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。
比如：将Redis用作日志收集器
实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。

取最新N个数据的操作



#### set（集合）



#### 及zset(sorted set：有序集合)



## 使用场景

1）发送手机验证码，5分钟过期；
   set key,value,timeout

2）避免当前用户频繁操作：接口频率；
   部分接口处理流程较长，避免被频繁调用，设置60秒；  
   set key,value,timeout

3）用户登录，
  1)下发随机数给前端，后端同时缓存到redis.
  2)前端作为密钥做hmac加密，后端同样使用该随机数做hmac验证。


4）分布式锁；
  密钥轮转口令模式；
   根密钥（即超级管理员口令）对轮转密钥做了sm4加密，加密存储在数据库内。密钥在轮转期间，要求根密钥不变；
   此时和超级管理员修改密码，保证不可并行。
   需要使用redis分布式锁。 先获取分布式锁，如果获取不到，提示返回。

 密钥轮转U盾模式；
   在创建U盾的公私钥时，根密钥（即超级管理员口令）对公私钥的明文做了sm4加密，加密存储在数据库，以备在U损损坏后，可重建U盾；
   用公钥对轮转密钥加密，存在数据库内，启动时，如果数据库内有，则使用私钥解密，加载轮转密钥明文到内存。


5）数据缓存；
   apps下载；

   1)发布新版本：一个版本，对应多个手机厂商；
   2）到后端拆分成多条数据：每一个手机厂商，对应一个版本和对应的下载地址，以及其它的灰度时间，灰度方式，生效时间等。
   3）后端把这多条数据存数据库；
   4）后端会把发布的数据缓存到redis, 使用zset（有续集合）的方式，每一个手机类型，按对应的app版本做倒叙排序，手机升级时获取最新的版本。
      这里为什么不只设置1条，却用多条做zset排序呢？ 因为这里有一个灰度时间和生效时间的问题，可能最新的那一条没生效，那会去判断第二条是否是最新的数据。





## redis分布式锁原理

Redis 通常可以使用 setnx(key, value) 函数来实现分布式锁。
key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。

setnx 函数的返回值有 0 和 1：
返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。
返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试 setnx 操作，以获得锁。

我还是以电商售卖吹风机的场景为例，和你说明基于缓存实现的分布式锁，假设现在库存数量是足够的。
用户 A 的请求因为网速快，最先到达 Server2，setnx 操作返回 1，并获取到购买吹风机的锁；用户 B 和用户 C 的请求，几乎同时到达了 Server1 和 Server3，但因为这时 Server2 获取到了吹风机数据的锁，所以只能加入等待队列。
Server2 获取到锁后，负责管理吹风机的服务器执行业务逻辑，只用了 1s 就完成了订单。订单请求完成后，删除锁的 key，从而释放锁。此时，排在第二顺位的 Server1 获得了锁，可以访问吹风机的数据资源。但不巧的是，Server1 在完成订单后发生了故障，无法主动释放锁。
于是，排在第三顺位的 Server3 只能等设定的有效时间（比如 30 分钟）到期，锁自动释放后，才能访问吹风机的数据资源，也就是说用户 C 只能到 00:30:01 以后才能继续抢购。

Redis 通过队列来维持进程访问共享资源的先后顺序。
Redis 锁主要基于 setnx 函数实现分布式锁，当进程通过 setnx<key,value> 函数返回 1 时，表示已经获得锁。排在后面的进程只能等待前面的进程主动释放锁，或者等到时间超时才能获得锁。

这个方案的不足是，通过超时时间来控制锁的失效时间，并不是十分靠谱，因为一个进程执行时间可能比较长，或受系统进程做内存回收等影响，导致时间超时，从而不正确地释放了锁。











